{"$message_type":"diagnostic","message":"the trait `Copy` cannot be implemented for this type","code":{"code":"E0204","explanation":"The `Copy` trait was implemented on a type which contains a field that doesn't\nimplement the `Copy` trait.\n\nErroneous code example:\n\n```compile_fail,E0204\nstruct Foo {\n    foo: Vec<u32>,\n}\n\nimpl Copy for Foo { } // error!\n```\n\nThe `Copy` trait is implemented by default only on primitive types. If your\ntype only contains primitive types, you'll be able to implement `Copy` on it.\nOtherwise, it won't be possible.\n\nHere's another example that will fail:\n\n```compile_fail,E0204\n#[derive(Copy)] // error!\nstruct Foo<'a> {\n    ty: &'a mut bool,\n}\n```\n\nThis fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\ndiffers from the behavior for `&T`, which is always `Copy`).\n"},"level":"error","spans":[{"file_name":"src\\simulation\\endgame.rs","byte_start":2720,"byte_end":2750,"line_start":99,"line_end":99,"column_start":5,"column_end":35,"is_primary":false,"text":[{"text":"    pub event: TransformationEvent,","highlight_start":5,"highlight_end":35}],"label":"this field does not implement `Copy`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\simulation\\endgame.rs","byte_start":2676,"byte_end":2680,"line_start":97,"line_end":97,"column_start":24,"column_end":28,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy)]","highlight_start":24,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\simulation\\endgame.rs","byte_start":2676,"byte_end":2680,"line_start":97,"line_end":97,"column_start":24,"column_end":28,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Copy)]","highlight_start":24,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Copy)]","def_site_span":{"file_name":"C:\\Users\\fezeh\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\marker.rs","byte_start":17319,"byte_end":17333,"line_start":473,"line_end":473,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"pub macro Copy($item:item) {","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0204]\u001b[0m\u001b[1m\u001b[97m: the trait `Copy` cannot be implemented for this type\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\simulation\\endgame.rs:97:24\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m97\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy)]\n   \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^\u001b[0m\n\u001b[1m\u001b[96m98\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct EndgameTransition {\n\u001b[1m\u001b[96m99\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub event: TransformationEvent,\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------------------------------\u001b[0m \u001b[1m\u001b[96mthis field does not implement `Copy`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `SignatureSpec: serde::Serialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\simulation\\agents.rs","byte_start":572,"byte_end":581,"line_start":21,"line_end":21,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize)]","highlight_start":24,"highlight_end":33}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\simulation\\agents.rs","byte_start":572,"byte_end":581,"line_start":21,"line_end":21,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Serialize)]","def_site_span":{"file_name":"C:\\Users\\fezeh\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_derive-1.0.228\\src\\lib.rs","byte_start":3101,"byte_end":3159,"line_start":114,"line_end":114,"column_start":1,"column_end":59,"is_primary":false,"text":[{"text":"pub fn derive_serialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\simulation\\agents.rs","byte_start":781,"byte_end":782,"line_start":29,"line_end":29,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    #[serde(default)]","highlight_start":5,"highlight_end":6}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Serialize` is not implemented for `SignatureSpec`","code":null,"level":"help","spans":[{"file_name":"src\\rules\\signature.rs","byte_start":557,"byte_end":581,"line_start":26,"line_end":26,"column_start":1,"column_end":25,"is_primary":true,"text":[{"text":"pub struct SignatureSpec {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for local types consider adding `#[derive(serde::Serialize)]` to your `SignatureSpec` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Serialize`:\n  &'a T\n  &'a mut T\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\n  (T0, T1, T2, T3, T4)\nand 217 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Vec<SignatureSpec>` to implement `Serialize`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `components::combat::_::_serde::ser::SerializeStruct::serialize_field`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\fezeh\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\ser\\mod.rs","byte_start":62575,"byte_end":62590,"line_start":1915,"line_end":1915,"column_start":8,"column_end":23,"is_primary":false,"text":[{"text":"    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>","highlight_start":8,"highlight_end":23}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\fezeh\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\ser\\mod.rs","byte_start":62692,"byte_end":62701,"line_start":1917,"line_end":1917,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"        T: ?Sized + Serialize;","highlight_start":21,"highlight_end":30}],"label":"required by this bound in `SerializeStruct::serialize_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `SignatureSpec: serde::Serialize` is not satisfied\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\simulation\\agents.rs:21:24\n     \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m21\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize)]\n     \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n  \u001b[1m\u001b[96m29\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[serde(default)]\n     \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m-\u001b[0m \u001b[1m\u001b[96mrequired by a bound introduced by this call\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `Serialize` is not implemented for `SignatureSpec`\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\rules\\signature.rs:26:1\n     \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m26\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct SignatureSpec {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for local types consider adding `#[derive(serde::Serialize)]` to your `SignatureSpec` type\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `Serialize`:\n               &'a T\n               &'a mut T\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n               (T0, T1, T2, T3)\n               (T0, T1, T2, T3, T4)\n             and 217 others\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `Vec<SignatureSpec>` to implement `Serialize`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `components::combat::_::_serde::ser::SerializeStruct::serialize_field`\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\fezeh\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\ser\\mod.rs:1917:21\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1915\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>\n     \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m---------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[96m1916\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     where\n\u001b[1m\u001b[96m1917\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         T: ?Sized + Serialize;\n     \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `SerializeStruct::serialize_field`\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: this error originates in the derive macro `Serialize` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `SignatureSpec: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\simulation\\agents.rs","byte_start":829,"byte_end":847,"line_start":30,"line_end":30,"column_start":30,"column_end":48,"is_primary":true,"text":[{"text":"    pub incident_signatures: Vec<SignatureSpec>,","highlight_start":30,"highlight_end":48}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Deserialize<'_>` is not implemented for `SignatureSpec`","code":null,"level":"help","spans":[{"file_name":"src\\rules\\signature.rs","byte_start":557,"byte_end":581,"line_start":26,"line_end":26,"column_start":1,"column_end":25,"is_primary":true,"text":[{"text":"pub struct SignatureSpec {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `SignatureSpec` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 232 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Vec<SignatureSpec>` to implement `Deserialize<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\fezeh\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\fezeh\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `SignatureSpec: serde::Deserialize<'de>` is not satisfied\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\simulation\\agents.rs:30:30\n     \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m30\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub incident_signatures: Vec<SignatureSpec>,\n     \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `Deserialize<'_>` is not implemented for `SignatureSpec`\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\rules\\signature.rs:26:1\n     \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m26\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct SignatureSpec {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `SignatureSpec` type\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n               &'a Path\n               &'a [u8]\n               &'a str\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n               (T0, T1, T2, T3)\n             and 232 others\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `Vec<SignatureSpec>` to implement `Deserialize<'_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `next_element`\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\fezeh\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs:1771:12\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1769\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>\n     \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[96m1770\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     where\n\u001b[1m\u001b[96m1771\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         T: Deserialize<'de>,\n     \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `SeqAccess::next_element`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `SignatureSpec: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\simulation\\agents.rs","byte_start":829,"byte_end":847,"line_start":30,"line_end":30,"column_start":30,"column_end":48,"is_primary":true,"text":[{"text":"    pub incident_signatures: Vec<SignatureSpec>,","highlight_start":30,"highlight_end":48}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Deserialize<'_>` is not implemented for `SignatureSpec`","code":null,"level":"help","spans":[{"file_name":"src\\rules\\signature.rs","byte_start":557,"byte_end":581,"line_start":26,"line_end":26,"column_start":1,"column_end":25,"is_primary":true,"text":[{"text":"pub struct SignatureSpec {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `SignatureSpec` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 232 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Vec<SignatureSpec>` to implement `Deserialize<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\fezeh\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\fezeh\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `SignatureSpec: serde::Deserialize<'de>` is not satisfied\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\simulation\\agents.rs:30:30\n     \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m30\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub incident_signatures: Vec<SignatureSpec>,\n     \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `Deserialize<'_>` is not implemented for `SignatureSpec`\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\rules\\signature.rs:26:1\n     \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m26\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct SignatureSpec {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `SignatureSpec` type\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n               &'a Path\n               &'a [u8]\n               &'a str\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n               (T0, T1, T2, T3)\n             and 232 others\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `Vec<SignatureSpec>` to implement `Deserialize<'_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `next_value`\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\fezeh\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs:1916:12\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1914\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[96m1915\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     where\n\u001b[1m\u001b[96m1916\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         V: Deserialize<'de>,\n     \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `MapAccess::next_value`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\simulation\\agents.rs","byte_start":5538,"byte_end":5547,"line_start":193,"line_end":193,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"            time.hour,","highlight_start":13,"highlight_end":22}],"label":"expected `u32`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\simulation\\agents.rs","byte_start":5413,"byte_end":5436,"line_start":190,"line_end":190,"column_start":31,"column_end":54,"is_primary":false,"text":[{"text":"        let target_location = default_target_location(","highlight_start":31,"highlight_end":54}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src\\simulation\\agents.rs","byte_start":7703,"byte_end":7712,"line_start":249,"line_end":249,"column_start":65,"column_end":74,"is_primary":false,"text":[{"text":"fn default_target_location(home: LocationId, haunt: LocationId, hour: u32) -> LocationId {","highlight_start":65,"highlight_end":74}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\simulation\\agents.rs","byte_start":7642,"byte_end":7665,"line_start":249,"line_end":249,"column_start":4,"column_end":27,"is_primary":true,"text":[{"text":"fn default_target_location(home: LocationId, haunt: LocationId, hour: u32) -> LocationId {","highlight_start":4,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u8` to a `u32`","code":null,"level":"help","spans":[{"file_name":"src\\simulation\\agents.rs","byte_start":5547,"byte_end":5547,"line_start":193,"line_end":193,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"            time.hour,","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\simulation\\agents.rs:193:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m190\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let target_location = default_target_location(\n    \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[96m-----------------------\u001b[0m \u001b[1m\u001b[96marguments to this function are incorrect\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m193\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             time.hour,\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `u32`, found `u8`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\simulation\\agents.rs:249:4\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m249\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn default_target_location(home: LocationId, haunt: LocationId, hour: u32) -> LocationId {\n    \u001b[1m\u001b[96m|\u001b[0m    \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m                                      \u001b[1m\u001b[96m---------\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert a `u8` to a `u32`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m193\u001b[0m \u001b[1m\u001b[96m| \u001b[0m            time.hour\u001b[92m.into()\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m                      \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type mismatch in function arguments","code":{"code":"E0631","explanation":"This error indicates a type mismatch in closure arguments.\n\nErroneous code example:\n\n```compile_fail,E0631\nfn foo<F: Fn(i32)>(f: F) {\n}\n\nfn main() {\n    foo(|x: &str| {});\n}\n```\n\nThe error occurs because `foo` accepts a closure that takes an `i32` argument,\nbut in `main`, it is passed a closure with a `&str` argument.\n\nThis can be resolved by changing the type annotation or removing it entirely\nif it can be inferred.\n\n```\nfn foo<F: Fn(i32)>(f: F) {\n}\n\nfn main() {\n    foo(|x: i32| {});\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\systems\\combat_loop.rs","byte_start":12236,"byte_end":12262,"line_start":371,"line_end":371,"column_start":18,"column_end":44,"is_primary":true,"text":[{"text":"            .map(SignatureSpec::to_instance)","highlight_start":18,"highlight_end":44}],"label":"expected due to this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\rules\\signature.rs","byte_start":890,"byte_end":936,"line_start":41,"line_end":41,"column_start":5,"column_end":51,"is_primary":false,"text":[{"text":"    pub fn to_instance(&self) -> SignatureInstance {","highlight_start":5,"highlight_end":51}],"label":"found signature defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\systems\\combat_loop.rs","byte_start":12232,"byte_end":12235,"line_start":371,"line_end":371,"column_start":14,"column_end":17,"is_primary":false,"text":[{"text":"            .map(SignatureSpec::to_instance)","highlight_start":14,"highlight_end":17}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected function signature `fn(SignatureSpec) -> _`\n   found function signature `fn(&SignatureSpec) -> _`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `std::iter::Iterator::map`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\fezeh\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\iter\\traits\\iterator.rs","byte_start":26907,"byte_end":26910,"line_start":773,"line_end":773,"column_start":8,"column_end":11,"is_primary":false,"text":[{"text":"    fn map<B, F>(self, f: F) -> Map<Self, F>","highlight_start":8,"highlight_end":11}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\fezeh\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\iter\\traits\\iterator.rs","byte_start":26987,"byte_end":27009,"line_start":776,"line_end":776,"column_start":12,"column_end":34,"is_primary":true,"text":[{"text":"        F: FnMut(Self::Item) -> B,","highlight_start":12,"highlight_end":34}],"label":"required by this bound in `Iterator::map`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider wrapping the function in a closure","code":null,"level":"help","spans":[{"file_name":"src\\systems\\combat_loop.rs","byte_start":12236,"byte_end":12236,"line_start":371,"line_end":371,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"            .map(SignatureSpec::to_instance)","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":"|arg0: SignatureSpec| ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\systems\\combat_loop.rs","byte_start":12262,"byte_end":12262,"line_start":371,"line_end":371,"column_start":44,"column_end":44,"is_primary":true,"text":[{"text":"            .map(SignatureSpec::to_instance)","highlight_start":44,"highlight_end":44}],"label":null,"suggested_replacement":"(&arg0)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider adjusting the signature so it does not borrow its argument","code":null,"level":"help","spans":[{"file_name":"src\\rules\\signature.rs","byte_start":909,"byte_end":910,"line_start":41,"line_end":41,"column_start":24,"column_end":25,"is_primary":true,"text":[{"text":"    pub fn to_instance(&self) -> SignatureInstance {","highlight_start":24,"highlight_end":25}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0631]\u001b[0m\u001b[1m\u001b[97m: type mismatch in function arguments\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\systems\\combat_loop.rs:371:18\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m371\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             .map(SignatureSpec::to_instance)\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected due to this\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m::: \u001b[0msrc\\rules\\signature.rs:41:5\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m41\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn to_instance(&self) -> SignatureInstance {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m----------------------------------------------\u001b[0m \u001b[1m\u001b[96mfound signature defined here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected function signature `fn(SignatureSpec) -> \u001b[1m\u001b[35m_\u001b[0m`\n               found function signature `fn(\u001b[1m\u001b[35m&\u001b[0mSignatureSpec) -> \u001b[1m\u001b[35m_\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::iter::Iterator::map`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\fezeh\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\iter\\traits\\iterator.rs:776:12\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m773\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn map<B, F>(self, f: F) -> Map<Self, F>\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m776\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         F: FnMut(Self::Item) -> B,\n    \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Iterator::map`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider wrapping the function in a closure\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m371\u001b[0m \u001b[1m\u001b[96m| \u001b[0m            .map(\u001b[92m|arg0: SignatureSpec| \u001b[0mSignatureSpec::to_instance\u001b[92m(&arg0)\u001b[0m)\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[92m+++++++++++++++++++++\u001b[0m                           \u001b[92m+++++++\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider adjusting the signature so it does not borrow its argument\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\rules\\signature.rs:41:24\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m41\u001b[0m \u001b[91m- \u001b[0m    pub fn to_instance(\u001b[91m&\u001b[0mself) -> SignatureInstance {\n \u001b[1m\u001b[96m41\u001b[0m \u001b[92m+ \u001b[0m    pub fn to_instance(self) -> SignatureInstance {\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `collect` exists for struct `Map<IntoIter<SignatureSpec>, fn(&...) -> ... {...::to_instance}>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\systems\\combat_loop.rs","byte_start":12181,"byte_end":12278,"line_start":369,"line_end":372,"column_start":21,"column_end":14,"is_primary":false,"text":[{"text":"        signatures: signatures","highlight_start":21,"highlight_end":31},{"text":"            .into_iter()","highlight_start":1,"highlight_end":25},{"text":"            .map(SignatureSpec::to_instance)","highlight_start":1,"highlight_end":45},{"text":"            .collect(),","highlight_start":1,"highlight_end":14}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\systems\\combat_loop.rs","byte_start":12278,"byte_end":12285,"line_start":372,"line_end":372,"column_start":14,"column_end":21,"is_primary":true,"text":[{"text":"            .collect(),","highlight_start":14,"highlight_end":21}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\fezeh\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\iter\\adapters\\map.rs","byte_start":2060,"byte_end":2080,"line_start":61,"line_end":61,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct Map<I, F> {","highlight_start":1,"highlight_end":21}],"label":"doesn't satisfy `_: Iterator`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`<for<'a> fn(&'a SignatureSpec) -> SignatureInstance {SignatureSpec::to_instance} as FnOnce<(SignatureSpec,)>>::Output = _`\nwhich is required by `std::iter::Map<std::vec::IntoIter<SignatureSpec>, for<'a> fn(&'a SignatureSpec) -> SignatureInstance {SignatureSpec::to_instance}>: Iterator`\n`for<'a> fn(&'a SignatureSpec) -> SignatureInstance {SignatureSpec::to_instance}: FnMut<(SignatureSpec,)>`\nwhich is required by `std::iter::Map<std::vec::IntoIter<SignatureSpec>, for<'a> fn(&'a SignatureSpec) -> SignatureInstance {SignatureSpec::to_instance}>: Iterator`\n`std::iter::Map<std::vec::IntoIter<SignatureSpec>, for<'a> fn(&'a SignatureSpec) -> SignatureInstance {SignatureSpec::to_instance}>: Iterator`\nwhich is required by `&mut std::iter::Map<std::vec::IntoIter<SignatureSpec>, for<'a> fn(&'a SignatureSpec) -> SignatureInstance {SignatureSpec::to_instance}>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to 'C:\\Users\\fezeh\\OneDrive\\Documents\\GitHub\\Collapsing-Worlds\\target\\debug\\deps\\superhero_universe-2cc0b225b02537d5.long-type-10466388200396521166.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: the method `collect` exists for struct `Map<IntoIter<SignatureSpec>, fn(&...) -> ... {...::to_instance}>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\systems\\combat_loop.rs:372:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m369\u001b[0m \u001b[1m\u001b[96m|\u001b[0m           signatures: signatures\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m _____________________-\u001b[0m\n\u001b[1m\u001b[96m370\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             .into_iter()\n\u001b[1m\u001b[96m371\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             .map(SignatureSpec::to_instance)\n\u001b[1m\u001b[96m372\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             .collect(),\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|_____________|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m::: \u001b[0mC:\\Users\\fezeh\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\iter\\adapters\\map.rs:61:1\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   pub struct Map<I, F> {\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m--------------------\u001b[0m \u001b[1m\u001b[96mdoesn't satisfy `_: Iterator`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: the following trait bounds were not satisfied:\n            `<for<'a> fn(&'a SignatureSpec) -> SignatureInstance {SignatureSpec::to_instance} as FnOnce<(SignatureSpec,)>>::Output = _`\n            which is required by `std::iter::Map<std::vec::IntoIter<SignatureSpec>, for<'a> fn(&'a SignatureSpec) -> SignatureInstance {SignatureSpec::to_instance}>: Iterator`\n            `for<'a> fn(&'a SignatureSpec) -> SignatureInstance {SignatureSpec::to_instance}: FnMut<(SignatureSpec,)>`\n            which is required by `std::iter::Map<std::vec::IntoIter<SignatureSpec>, for<'a> fn(&'a SignatureSpec) -> SignatureInstance {SignatureSpec::to_instance}>: Iterator`\n            `std::iter::Map<std::vec::IntoIter<SignatureSpec>, for<'a> fn(&'a SignatureSpec) -> SignatureInstance {SignatureSpec::to_instance}>: Iterator`\n            which is required by `&mut std::iter::Map<std::vec::IntoIter<SignatureSpec>, for<'a> fn(&'a SignatureSpec) -> SignatureInstance {SignatureSpec::to_instance}>: Iterator`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: the full name for the type has been written to 'C:\\Users\\fezeh\\OneDrive\\Documents\\GitHub\\Collapsing-Worlds\\target\\debug\\deps\\superhero_universe-2cc0b225b02537d5.long-type-10466388200396521166.txt'\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"can't call method `max` on ambiguous numeric type `{float}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\systems\\pressure.rs","byte_start":1489,"byte_end":1492,"line_start":48,"line_end":48,"column_start":47,"column_end":50,"is_primary":true,"text":[{"text":"        max_case_progress = max_case_progress.max(case.progress as f32);","highlight_start":47,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `f32`","code":null,"level":"help","spans":[{"file_name":"src\\systems\\pressure.rs","byte_start":1244,"byte_end":1244,"line_start":42,"line_end":42,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"    let mut max_case_progress = 0.0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": f32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0689]\u001b[0m\u001b[1m\u001b[97m: can't call method `max` on ambiguous numeric type `{float}`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\systems\\pressure.rs:48:47\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m48\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         max_case_progress = max_case_progress.max(case.progress as f32);\n   \u001b[1m\u001b[96m|\u001b[0m                                               \u001b[1m\u001b[91m^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you must specify a type for this binding, like `f32`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m42\u001b[0m \u001b[1m\u001b[96m| \u001b[0m    let mut max_case_progress\u001b[92m: f32\u001b[0m = 0.0;\n   \u001b[1m\u001b[96m|\u001b[0m                              \u001b[92m+++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"can't call method `clamp` on ambiguous numeric type `{float}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\systems\\pressure.rs","byte_start":1656,"byte_end":1661,"line_start":52,"line_end":52,"column_start":71,"column_end":76,"is_primary":true,"text":[{"text":"    let case_pressure = (max_case_progress + active_case_count * 8.0).clamp(0.0, 100.0);","highlight_start":71,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0689]\u001b[0m\u001b[1m\u001b[97m: can't call method `clamp` on ambiguous numeric type `{float}`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\systems\\pressure.rs:52:71\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m52\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let case_pressure = (max_case_progress + active_case_count * 8.0).clamp(0.0, 100.0);\n   \u001b[1m\u001b[96m|\u001b[0m                                                                       \u001b[1m\u001b[91m^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `entry` exists for struct `HashMap<StoryletCategory, usize>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\ui\\authoring.rs","byte_start":1705,"byte_end":1710,"line_start":44,"line_end":44,"column_start":26,"column_end":31,"is_primary":true,"text":[{"text":"        *category_counts.entry(storylet.category).or_insert(0) += 1;","highlight_start":26,"highlight_end":31}],"label":"method cannot be called on `HashMap<StoryletCategory, usize>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\data\\storylets.rs","byte_start":909,"byte_end":934,"line_start":37,"line_end":37,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"pub enum StoryletCategory {","highlight_start":1,"highlight_end":26}],"label":"doesn't satisfy `StoryletCategory: Eq` or `StoryletCategory: Hash`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`StoryletCategory: Eq`\n`StoryletCategory: Hash`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider annotating `StoryletCategory` with `#[derive(Eq, Hash, PartialEq)]`","code":null,"level":"help","spans":[{"file_name":"src\\data\\storylets.rs","byte_start":909,"byte_end":909,"line_start":37,"line_end":37,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub enum StoryletCategory {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(Eq, Hash, PartialEq)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: the method `entry` exists for struct `HashMap<StoryletCategory, usize>`, but its trait bounds were not satisfied\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\ui\\authoring.rs:44:26\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m44\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         *category_counts.entry(storylet.category).or_insert(0) += 1;\n   \u001b[1m\u001b[96m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `HashMap<StoryletCategory, usize>` due to unsatisfied trait bounds\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m::: \u001b[0msrc\\data\\storylets.rs:37:1\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m37\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub enum StoryletCategory {\n   \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m-------------------------\u001b[0m \u001b[1m\u001b[96mdoesn't satisfy `StoryletCategory: Eq` or `StoryletCategory: Hash`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: the following trait bounds were not satisfied:\n           `StoryletCategory: Eq`\n           `StoryletCategory: Hash`\n\u001b[1m\u001b[96mhelp\u001b[0m: consider annotating `StoryletCategory` with `#[derive(Eq, Hash, PartialEq)]`\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\data\\storylets.rs:37:1\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m37\u001b[0m \u001b[92m+ #[derive(Eq, Hash, PartialEq)]\u001b[0m\n\u001b[1m\u001b[96m38\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub enum StoryletCategory {\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of moved value: `form`","code":{"code":"E0382","explanation":"A variable was used after its contents have been moved elsewhere.\n\nErroneous code example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`. Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the\n[Understanding Ownership][understanding-ownership] chapter in the Book.\n\n[understanding-ownership]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n"},"level":"error","spans":[{"file_name":"src\\simulation\\nemesis.rs","byte_start":1507,"byte_end":1511,"line_start":49,"line_end":49,"column_start":29,"column_end":33,"is_primary":false,"text":[{"text":"            self.forms.push(form);","highlight_start":29,"highlight_end":33}],"label":"value moved here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\simulation\\nemesis.rs","byte_start":1558,"byte_end":1562,"line_start":51,"line_end":51,"column_start":33,"column_end":37,"is_primary":true,"text":[{"text":"        *self.form_counts.entry(form).or_insert(0) += 1;","highlight_start":33,"highlight_end":37}],"label":"value used here after move","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\simulation\\nemesis.rs","byte_start":1420,"byte_end":1424,"line_start":47,"line_end":47,"column_start":35,"column_end":39,"is_primary":false,"text":[{"text":"    pub fn record_form(&mut self, form: String) {","highlight_start":35,"highlight_end":39}],"label":"move occurs because `form` has type `std::string::String`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"src\\simulation\\nemesis.rs","byte_start":1511,"byte_end":1511,"line_start":49,"line_end":49,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"            self.forms.push(form);","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0382]\u001b[0m\u001b[1m\u001b[97m: use of moved value: `form`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\simulation\\nemesis.rs:51:33\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m47\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn record_form(&mut self, form: String) {\n   \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[1m\u001b[96m----\u001b[0m \u001b[1m\u001b[96mmove occurs because `form` has type `std::string::String`, which does not implement the `Copy` trait\u001b[0m\n\u001b[1m\u001b[96m48\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if !self.forms.contains(&form) {\n\u001b[1m\u001b[96m49\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             self.forms.push(form);\n   \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[96m----\u001b[0m \u001b[1m\u001b[96mvalue moved here\u001b[0m\n\u001b[1m\u001b[96m50\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         }\n\u001b[1m\u001b[96m51\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         *self.form_counts.entry(form).or_insert(0) += 1;\n   \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvalue used here after move\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m49\u001b[0m \u001b[1m\u001b[96m| \u001b[0m            self.forms.push(form\u001b[92m.clone()\u001b[0m);\n   \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*director` as mutable because it is also borrowed as immutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src\\systems\\region.rs","byte_start":5247,"byte_end":5468,"line_start":174,"line_end":181,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            push_global_event(","highlight_start":13,"highlight_end":31},{"text":"                director,","highlight_start":1,"highlight_end":26},{"text":"                log,","highlight_start":1,"highlight_end":21},{"text":"                def,","highlight_start":1,"highlight_end":21},{"text":"                GlobalFactionScope::Global,","highlight_start":1,"highlight_end":44},{"text":"                &threshold.level,","highlight_start":1,"highlight_end":34},{"text":"                &threshold.actions,","highlight_start":1,"highlight_end":36},{"text":"            );","highlight_start":1,"highlight_end":14}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\systems\\region.rs","byte_start":5112,"byte_end":5132,"line_start":172,"line_end":172,"column_start":16,"column_end":36,"is_primary":false,"text":[{"text":"    for def in director.definitions.iter() {","highlight_start":16,"highlight_end":36}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\systems\\region.rs","byte_start":5112,"byte_end":5139,"line_start":172,"line_end":172,"column_start":16,"column_end":43,"is_primary":false,"text":[{"text":"    for def in director.definitions.iter() {","highlight_start":16,"highlight_end":43}],"label":"immutable borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\systems\\region.rs","byte_start":5112,"byte_end":5139,"line_start":172,"line_end":172,"column_start":16,"column_end":43,"is_primary":false,"text":[{"text":"    for def in director.definitions.iter() {","highlight_start":16,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m\u001b[97m: cannot borrow `*director` as mutable because it is also borrowed as immutable\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\systems\\region.rs:174:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m172\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       for def in director.definitions.iter() {\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[96m---------------------------\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[96mimmutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[96mimmutable borrow later used here\u001b[0m\n\u001b[1m\u001b[96m173\u001b[0m \u001b[1m\u001b[96m|\u001b[0m           if let Some(threshold) = select_global_threshold(&def.global_thresholds, region) {\n\u001b[1m\u001b[96m174\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m             push_global_event(\n\u001b[1m\u001b[96m175\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 director,\n\u001b[1m\u001b[96m176\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 log,\n\u001b[1m\u001b[96m177\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 def,\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m180\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 &threshold.actions,\n\u001b[1m\u001b[96m181\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             );\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____________^\u001b[0m \u001b[1m\u001b[91mmutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*director` as mutable because it is also borrowed as immutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src\\systems\\region.rs","byte_start":5784,"byte_end":6045,"line_start":190,"line_end":197,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                push_global_event(","highlight_start":17,"highlight_end":35},{"text":"                    director,","highlight_start":1,"highlight_end":30},{"text":"                    log,","highlight_start":1,"highlight_end":25},{"text":"                    def,","highlight_start":1,"highlight_end":25},{"text":"                    GlobalFactionScope::Region(*region_id),","highlight_start":1,"highlight_end":60},{"text":"                    &threshold.level,","highlight_start":1,"highlight_end":38},{"text":"                    &threshold.actions,","highlight_start":1,"highlight_end":40},{"text":"                );","highlight_start":1,"highlight_end":18}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\systems\\region.rs","byte_start":5112,"byte_end":5132,"line_start":172,"line_end":172,"column_start":16,"column_end":36,"is_primary":false,"text":[{"text":"    for def in director.definitions.iter() {","highlight_start":16,"highlight_end":36}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\systems\\region.rs","byte_start":5112,"byte_end":5139,"line_start":172,"line_end":172,"column_start":16,"column_end":43,"is_primary":false,"text":[{"text":"    for def in director.definitions.iter() {","highlight_start":16,"highlight_end":43}],"label":"immutable borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\systems\\region.rs","byte_start":5112,"byte_end":5139,"line_start":172,"line_end":172,"column_start":16,"column_end":43,"is_primary":false,"text":[{"text":"    for def in director.definitions.iter() {","highlight_start":16,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m\u001b[97m: cannot borrow `*director` as mutable because it is also borrowed as immutable\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\systems\\region.rs:190:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m172\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       for def in director.definitions.iter() {\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[96m---------------------------\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[96mimmutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[96mimmutable borrow later used here\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m190\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m                 push_global_event(\n\u001b[1m\u001b[96m191\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     director,\n\u001b[1m\u001b[96m192\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     log,\n\u001b[1m\u001b[96m193\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     def,\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m196\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     &threshold.actions,\n\u001b[1m\u001b[96m197\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 );\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_________________^\u001b[0m \u001b[1m\u001b[91mmutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*city` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src\\systems\\heat.rs","byte_start":3745,"byte_end":3749,"line_start":112,"line_end":112,"column_start":40,"column_end":44,"is_primary":true,"text":[{"text":"        update_response(location, log, city, city_events);","highlight_start":40,"highlight_end":44}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\systems\\heat.rs","byte_start":3596,"byte_end":3610,"line_start":110,"line_end":110,"column_start":29,"column_end":43,"is_primary":false,"text":[{"text":"    if let Some(location) = city.locations.get_mut(&location_id) {","highlight_start":29,"highlight_end":43}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\systems\\heat.rs","byte_start":3714,"byte_end":3729,"line_start":112,"line_end":112,"column_start":9,"column_end":24,"is_primary":false,"text":[{"text":"        update_response(location, log, city, city_events);","highlight_start":9,"highlight_end":24}],"label":"mutable borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m\u001b[97m: cannot borrow `*city` as immutable because it is also borrowed as mutable\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\systems\\heat.rs:112:40\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m110\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     if let Some(location) = city.locations.get_mut(&location_id) {\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[96m--------------\u001b[0m \u001b[1m\u001b[96mmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[96m111\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         location.heat = (location.heat + total_delta).clamp(0, 100);\n\u001b[1m\u001b[96m112\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         update_response(location, log, city, city_events);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m---------------\u001b[0m                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mimmutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96mmutable borrow later used by call\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*city` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src\\systems\\heat.rs","byte_start":4471,"byte_end":4475,"line_start":133,"line_end":133,"column_start":45,"column_end":49,"is_primary":true,"text":[{"text":"        update_response(location, &mut log, city, city_events);","highlight_start":45,"highlight_end":49}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\systems\\heat.rs","byte_start":3940,"byte_end":3954,"line_start":118,"line_end":118,"column_start":21,"column_end":35,"is_primary":false,"text":[{"text":"    for location in city.locations.values_mut() {","highlight_start":21,"highlight_end":35}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\systems\\heat.rs","byte_start":3940,"byte_end":3967,"line_start":118,"line_end":118,"column_start":21,"column_end":48,"is_primary":false,"text":[{"text":"    for location in city.locations.values_mut() {","highlight_start":21,"highlight_end":48}],"label":"mutable borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\systems\\heat.rs","byte_start":3940,"byte_end":3967,"line_start":118,"line_end":118,"column_start":21,"column_end":48,"is_primary":false,"text":[{"text":"    for location in city.locations.values_mut() {","highlight_start":21,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m\u001b[97m: cannot borrow `*city` as immutable because it is also borrowed as mutable\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\systems\\heat.rs:133:45\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m118\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     for location in city.locations.values_mut() {\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[96m---------------------------\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[96mmutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[96mmutable borrow later used here\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m133\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         update_response(location, &mut log, city, city_events);\n    \u001b[1m\u001b[96m|\u001b[0m                                             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mimmutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*city` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src\\systems\\heat.rs","byte_start":5228,"byte_end":5232,"line_start":155,"line_end":155,"column_start":40,"column_end":44,"is_primary":true,"text":[{"text":"        update_response(location, log, city, city_events);","highlight_start":40,"highlight_end":44}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\systems\\heat.rs","byte_start":5079,"byte_end":5093,"line_start":153,"line_end":153,"column_start":29,"column_end":43,"is_primary":false,"text":[{"text":"    if let Some(location) = city.locations.get_mut(&location_id) {","highlight_start":29,"highlight_end":43}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\systems\\heat.rs","byte_start":5197,"byte_end":5212,"line_start":155,"line_end":155,"column_start":9,"column_end":24,"is_primary":false,"text":[{"text":"        update_response(location, log, city, city_events);","highlight_start":9,"highlight_end":24}],"label":"mutable borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m\u001b[97m: cannot borrow `*city` as immutable because it is also borrowed as mutable\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\systems\\heat.rs:155:40\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m153\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     if let Some(location) = city.locations.get_mut(&location_id) {\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[96m--------------\u001b[0m \u001b[1m\u001b[96mmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[96m154\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         location.heat = (location.heat + total_delta).clamp(0, 100);\n\u001b[1m\u001b[96m155\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         update_response(location, log, city, city_events);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m---------------\u001b[0m                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mimmutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96mmutable borrow later used by call\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 16 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: aborting due to 16 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0204, E0277, E0308, E0382, E0502, E0599, E0631, E0689.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mSome errors have detailed explanations: E0204, E0277, E0308, E0382, E0502, E0599, E0631, E0689.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0204`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about an error, try `rustc --explain E0204`.\u001b[0m\n"}
